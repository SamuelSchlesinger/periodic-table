use crate::element::Element;
use ratatui::{
    layout::{Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span},
    widgets::{Block, Borders, Paragraph, Wrap},
    Frame,
};
use crossterm::event::{Event, KeyCode, KeyEvent, KeyEventKind, MouseButton, MouseEvent, MouseEventKind};

pub struct PeriodicTableUi {
    pub table_layout: Vec<Vec<Option<Element>>>,
    pub selected_element: Option<Element>,
    pub cursor_position: (usize, usize),
}

impl PeriodicTableUi {
    pub fn new(table_layout: Vec<Vec<Option<Element>>>) -> Self {
        // Initialize with first valid element selected
        let mut ui = Self {
            table_layout,
            selected_element: None,
            cursor_position: (0, 0),
        };

        // Find the first valid element position
        ui.find_and_select_valid_element();
        ui
    }

    // Helper function to find a valid element position
    fn find_and_select_valid_element(&mut self) {
        for (row_idx, row) in self.table_layout.iter().enumerate() {
            for (col_idx, element_opt) in row.iter().enumerate() {
                if element_opt.is_some() {
                    self.cursor_position = (row_idx, col_idx);
                    self.update_selected_element();
                    return;
                }
            }
        }
    }

    pub fn render(&self, frame: &mut Frame) {
        let size = frame.area();

        // Create main layout
        let chunks = Layout::default()
            .direction(Direction::Vertical)
            .constraints([
                Constraint::Length(1),  // Title
                Constraint::Min(10),    // Table
                Constraint::Length(10), // Element details
            ])
            .split(size);

        // Render title with helpful instructions
        frame.render_widget(
            Paragraph::new("Periodic Table (Use arrow keys to navigate, Enter to select, q to quit)")
                .style(Style::default().fg(Color::White).add_modifier(Modifier::BOLD)),
            chunks[0],
        );

        // Render periodic table
        self.render_table(frame, chunks[1]);

        // Render element details
        self.render_element_details(frame, chunks[2]);
    }

    fn render_table(&self, frame: &mut Frame, area: Rect) {
        // Calculate cell size based on available area
        let rows = self.table_layout.len();
        let cols = if rows > 0 { self.table_layout[0].len() } else { 0 };

        // Set cell size for proper border alignment
        let cell_width = 6;  // Adjusted for proper border alignment
        let cell_height = 4; // Height for atomic number and symbol
        
        let total_width = cols * cell_width;
        let total_height = rows * cell_height;
        
        // Center the table in the available area
        let x_offset = (area.width.saturating_sub(total_width as u16)) / 2;
        let y_offset = (area.height.saturating_sub(total_height as u16)) / 2;
        
        // Render each element
        for (row_idx, row) in self.table_layout.iter().enumerate() {
            for (col_idx, element_opt) in row.iter().enumerate() {
                if let Some(element) = element_opt {
                    let cell_x = x_offset + (col_idx * cell_width) as u16;
                    let cell_y = y_offset + (row_idx * cell_height) as u16;
                    
                    if cell_x + cell_width as u16 <= area.width && cell_y + cell_height as u16 <= area.height {
                        // Create cell rectangle with exact dimensions to ensure borders align
                        let cell_rect = Rect::new(
                            area.x + cell_x,
                            area.y + cell_y,
                            cell_width as u16,
                            cell_height as u16,
                        );
                        
                        // Convert RGB color to terminal color
                        let (r, g, b) = element.color();
                        let bg_color = Color::Rgb(r, g, b);
                        
                        // Highlight selected element
                        let is_selected = self.cursor_position == (row_idx, col_idx);
                        // Determine a good contrasting color for the text
                        // For lighter background colors, use black; for darker ones, use white
                        let brightness = (r as u16 + g as u16 + b as u16) / 3;
                        let text_color = if brightness > 128 { Color::Black } else { Color::White };

                        // Determine if we need to make the text bold for selected items
                        let text_bold = is_selected;
                        
                        // Element content - using plain strings (styling is handled by the block)
                        let symbol = Line::from(element.symbol.clone());

                        // Add atomic number on a separate line (styling is handled by the block)
                        let atomic_number = Line::from(element.number.to_string());

                        // Create a block with black borders for all elements
                        let element_block = if is_selected {
                            // For selected elements, use a highlighted background
                            let highlight_bg = if brightness > 128 {
                                // For light backgrounds, darken slightly
                                Color::Rgb((r as u16 * 85 / 100) as u8,
                                          (g as u16 * 85 / 100) as u8,
                                          (b as u16 * 85 / 100) as u8)
                            } else {
                                // For dark backgrounds, brighten slightly
                                Color::Rgb(r.saturating_add(40),
                                          g.saturating_add(40),
                                          b.saturating_add(40))
                            };

                            let style = Style::default()
                                .bg(highlight_bg)
                                .fg(text_color);

                            if text_bold {
                                Block::default()
                                    .borders(Borders::ALL)
                                    .border_style(Style::default().fg(Color::Black))
                                    .style(style.add_modifier(Modifier::BOLD))
                            } else {
                                Block::default()
                                    .borders(Borders::ALL)
                                    .border_style(Style::default().fg(Color::Black))
                                    .style(style)
                            }
                        } else {
                            let style = Style::default()
                                .bg(bg_color)
                                .fg(text_color);

                            Block::default()
                                .borders(Borders::ALL)
                                .border_style(Style::default().fg(Color::Black))
                                .style(style)
                        };

                        // Create element widget with padding set to 0 to remove margins
                        let element_widget = Paragraph::new(vec![
                            atomic_number,  // Show atomic number first
                            symbol,         // Then element symbol
                        ])
                        .block(element_block)
                        .alignment(ratatui::layout::Alignment::Center);
                        
                        frame.render_widget(element_widget, cell_rect);
                    }
                }
            }
        }
    }

    fn render_element_details(&self, frame: &mut Frame, area: Rect) {
        let detail_block = Block::default()
            .title(Span::styled("Element Details", Style::default().add_modifier(Modifier::BOLD)))
            .borders(Borders::ALL)
            .border_style(Style::default().fg(Color::White));
        
        let inner_area = detail_block.inner(area);
        frame.render_widget(detail_block, area);
        
        if let Some(element) = &self.selected_element {
            let details = vec![
                Line::from(vec![
                    Span::styled(
                        format!("{}: {} ({})", element.number, element.name, element.symbol),
                        Style::default().add_modifier(Modifier::BOLD),
                    )
                ]),
                Line::from(vec![
                    Span::raw(format!("Atomic Mass: {}", element.mass))
                ]),
                Line::from(vec![
                    Span::raw(format!("Category: {:?}", element.category))
                ]),
                Line::from(""),
                Line::from(vec![
                    Span::raw(&element.description)
                ]),
            ];
            
            let paragraph = Paragraph::new(details)
                .wrap(Wrap { trim: true })
                .style(Style::default());
            
            frame.render_widget(paragraph, inner_area);
        } else {
            let text = vec![
                Line::from(vec![
                    Span::raw("Select an element to see details")
                ]),
            ];
            
            let paragraph = Paragraph::new(text)
                .style(Style::default());
            
            frame.render_widget(paragraph, inner_area);
        }
    }

    pub fn handle_event(&mut self, event: &Event) -> bool {
        match event {
            Event::Key(KeyEvent {
                code: KeyCode::Char('q'),
                kind: KeyEventKind::Press,
                ..
            }) => {
                return false;
            }
            Event::Key(KeyEvent {
                code: KeyCode::Up,
                kind: KeyEventKind::Press,
                ..
            }) => {
                if self.cursor_position.0 > 0 {
                    let old_row = self.cursor_position.0;
                    self.cursor_position.0 -= 1;

                    // If we moved to an empty spot, try to find a valid element in this row
                    if !self.is_valid_position() {
                        self.find_valid_element_in_row(self.cursor_position.0);
                        // If still not valid, go back to original position
                        if !self.is_valid_position() {
                            self.cursor_position.0 = old_row;
                        }
                    }
                    self.update_selected_element();
                }
            }
            Event::Key(KeyEvent {
                code: KeyCode::Down,
                kind: KeyEventKind::Press,
                ..
            }) => {
                if self.cursor_position.0 < self.table_layout.len() - 1 {
                    let old_row = self.cursor_position.0;
                    self.cursor_position.0 += 1;

                    // If we moved to an empty spot, try to find a valid element in this row
                    if !self.is_valid_position() {
                        self.find_valid_element_in_row(self.cursor_position.0);
                        // If still not valid, go back to original position
                        if !self.is_valid_position() {
                            self.cursor_position.0 = old_row;
                        }
                    }
                    self.update_selected_element();
                }
            }
            Event::Key(KeyEvent {
                code: KeyCode::Left,
                kind: KeyEventKind::Press,
                ..
            }) => {
                if self.cursor_position.1 > 0 {
                    let old_col = self.cursor_position.1;
                    self.cursor_position.1 -= 1;

                    // Keep moving left until we find a valid element or reach the edge
                    while !self.is_valid_position() && self.cursor_position.1 > 0 {
                        self.cursor_position.1 -= 1;
                    }

                    // If we still don't have a valid element, go back to original position
                    if !self.is_valid_position() {
                        self.cursor_position.1 = old_col;
                    }

                    self.update_selected_element();
                }
            }
            Event::Key(KeyEvent {
                code: KeyCode::Right,
                kind: KeyEventKind::Press,
                ..
            }) => {
                if !self.table_layout.is_empty() && self.cursor_position.1 < self.table_layout[0].len() - 1 {
                    let old_col = self.cursor_position.1;
                    self.cursor_position.1 += 1;

                    // Keep moving right until we find a valid element or reach the edge
                    while !self.is_valid_position() &&
                          self.cursor_position.1 < self.table_layout[0].len() - 1 {
                        self.cursor_position.1 += 1;
                    }

                    // If we still don't have a valid element, go back to original position
                    if !self.is_valid_position() {
                        self.cursor_position.1 = old_col;
                    }

                    self.update_selected_element();
                }
            }
            Event::Key(KeyEvent {
                code: KeyCode::Enter,
                kind: KeyEventKind::Press,
                ..
            }) => {
                self.update_selected_element();
            }
            Event::Mouse(MouseEvent {
                kind: MouseEventKind::Down(MouseButton::Left),
                column,
                row,
                ..
            }) => {
                // Convert mouse coordinates to table coordinates
                // This is simplified and would need adjustment based on actual rendering
                let cell_width = 6;  // Updated to match render_table
                let cell_height = 4; // Updated to match render_table
                
                // Calculate table offset
                let rows = self.table_layout.len();
                let cols = if rows > 0 { self.table_layout[0].len() } else { 0 };
                
                let total_width = cols * cell_width;
                let total_height = rows * cell_height;
                
                // Match the logic in render_table for consistent calculations
                let x_offset = (*column as u16).saturating_sub((total_width as u16) / 2);
                let y_offset = (*row as u16).saturating_sub((total_height as u16) / 2);

                let table_col = (x_offset as usize) / cell_width;
                let table_row = (y_offset as usize) / cell_height;

                if table_row < self.table_layout.len() &&
                   table_col < self.table_layout[0].len() &&
                   self.table_layout[table_row][table_col].is_some() {
                    self.cursor_position = (table_row, table_col);
                    self.update_selected_element();
                }
            }
            _ => {}
        }
        true
    }

    // Check if current position has a valid element
    fn is_valid_position(&self) -> bool {
        let (row, col) = self.cursor_position;
        if row < self.table_layout.len() && col < self.table_layout[row].len() {
            self.table_layout[row][col].is_some()
        } else {
            false
        }
    }

    // Find a valid element in the specified row
    fn find_valid_element_in_row(&mut self, row: usize) {
        if row >= self.table_layout.len() {
            return;
        }

        for col in 0..self.table_layout[row].len() {
            if self.table_layout[row][col].is_some() {
                self.cursor_position.1 = col;
                return;
            }
        }
    }

    fn update_selected_element(&mut self) {
        let (row, col) = self.cursor_position;
        if row < self.table_layout.len() && col < self.table_layout[row].len() {
            self.selected_element = self.table_layout[row][col].clone();
        }
    }
}